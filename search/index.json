[{"content":"Compound Data eg.1 Add Method for Relational Number Every realational number can be expressed by a fractional number.\n$$ x=\\frac{m}{n},y=\\frac{p}{q}, (x,y \\in R;m,n,p,q\\in Z) $$ $$ x+y=\\frac{mq+pn}{nq} $$\n1 2 3 4 5 6 7 8 (define (+rat x y) (make-rat (+ (* (numer x) (denom y)) (* (numer y) (denom x)) ) (* (denom x) (denom y)) ) ) List Structure The feature can be used to implement make-rat.\n1 2 3 4 5 6 7 8 ; constructs a pair whose first part is x and whose second part is y. (cons x y) ; =\u0026gt; [x, y] ; selects the first part of the pair p (car p) ; =\u0026gt; [x, y][0], aka x ; selects the second part of the pair p (cdr p) ; =\u0026gt; [x, y][1], aka y ATTENTION cons can constructs a pair no matter what the type of x, y\n1 2 3 4 5 6 7 8 9 (define (make-rat n d) (cons n d) ) (define (numer x) (car x) ) (define (denam x) (cdr x) ) let use let to define a local variable.\n","date":"2023-05-02T13:58:20+08:00","permalink":"https://resyon.netlify.app/p/sicp_lec_2b/","title":"SICP_Lec_2b"},{"content":"High-Order Procedure(Iterative) eg.1 sum of integer $$ \\sum\\nolimits_{i=a} ^{b}{i} $$\n1 2 3 4 5 6 7 ; primitive procedure 1+ 1- (define (soi a b) (if (\u0026gt; a b) 0 (+ (soi (1+ a) b) a) ) ) eg.2 sum of square $$ \\sum\\nolimits_{i=a}^{b}{i^2} $$\n1 2 3 4 5 6 7 (define (soq a b) (define (square x)(* x x)) (if (\u0026gt; a b) 0 (+ (soi (1+ a) b) (square a))) ) eg.3 Leibnitz\u0026rsquo;s formula Following formula is designed to find value of\n$$ \\frac{\\pi}{8} = \\lim_{b\\to+\\infty}\\sum\\nolimits_{i=a;by4}^{b}\\frac{1}{{i(i+1)}} $$\n1 2 3 4 5 6 7 (define (pi-sum a b) (if (\u0026gt; a b) 0 (+ (pi-sum (+ 4 a) b) (/ 1 (* a (+1 a))) )) ) general pattern of above example 1 2 3 4 5 6 7 (define (\u0026lt;name\u0026gt; a b) (if (\u0026gt; a b) 0 (+ (\u0026lt;name\u0026gt; (\u0026lt;next\u0026gt; a) b) (\u0026lt;handle\u0026gt; a)) ) ) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 (define (sum a identity next b) (if (\u0026gt; a b) 0 (+ (sum (next a) b) (identity a)) ) ) (define (soi a b) (define (identity x) x) (sum identity a 1+ b) ) (define (soq a b) (define (identity x) (* x x)) (sum identity a 1+ b) ) Iterative 1 2 3 4 5 6 7 8 (define (sum term a next) (define (iter j ans) (if (\u0026gt; j b) ans (iter (next j) (+ (term j) ans)))) (iter a 0)) eg.4 Heron of Alexandria\u0026rsquo;s method It is used to compute square roots.\nIt can be viewed as a iterative procedure finding a fixed point.\nAbstraction of this method:\n1 2 3 4 5 (define (sqrt x ) (fixed-point (lambda (y) (average (/ x y) y)) 1) ) Details of it:\n1 2 3 4 5 6 7 8 9 10 ; f: method to get close to fixed-point (define (fixed-point f start) (define (iter old new) (if (close_enough? old new) new (iter new (f new))) ) (iter start (f start)) ) eg.5 Average Damp 1 2 3 4 5 6 7 (define (sqrt x) (fixed-point (average_damp (lambda (y)) (/ x y)) 1) ) 1 2 3 4 5 6 7 (define average_damp (lambda (f) (lambda (x) (average (f x) x) ) ) ) the same as below\n1 2 3 4 (define (average-damp f) (define (foo x) (average (f x) x)) foo) eg.6 Newton\u0026rsquo;s method To find a y to such that $$ f(y) = 0 $$ start with a guess y0\n$$ y_{n+1} = y_{n} - {\\frac{f(y_{n})}{\\frac{\\mathrm{d} f}{\\mathrm{d} y}|_{y=y_n}}} $$\nApply this method to compute a sqrt root of x:\n1 2 3 4 5 6 (define (sqrt x) (newton (lambda (y) (- x (square y)) ) 1) ) Details:\n1 2 3 4 5 6 7 (define (newton f guess) (define df (deriv f)) (fixed-point (lambda (x) (- x (/ (f x) (df x)))) guess ) ) How to define deriv?\n$$ f\u0026rsquo;(x) = \\frac{f(x+{\\mathrm{d x}})-f(x)}{\\mathrm{d} x} $$\n1 2 3 4 5 6 7 (define deriv (lambda (f) (lambda (x) (/ (- (f (+ x dx)) (f x)) dx))) ) $$ {\\mathrm{d} x}? $$\n1 2 ; an ugly but simple method (define dx 0.0000001) ","date":"2023-04-30T20:21:15+08:00","permalink":"https://resyon.netlify.app/p/sicp_lec_2a/","title":"SICP_Lec_2a"},{"content":"Recursive Some prossible methods to implement operator+.\nprerequisites There exists some primitive procedures, which are implemented in other method finally.\n1 2 3 4 ; 1- (define (1- x) ...) ; 1+ (define (1+ x) ...) eg.1 operator+\n1 2 3 4 5 6 ; provided that x is non-negative integer (define (+ x y) if (= 0 x) x (+ (1- x) (1+ y))) an instance\n1 (+ 3 4) inspect the compute procedure:\n1 2 3 4 5 6 7 8 (+ 3 4) (+ (1- 3) (1+ 4)) (+ 2, 5) (+ (1- 2) (1+ 5)) (+ 1, 6) (+ (1- 1) (1+ 6)) (+ 0, 7) 7 eg.2 fibonacci\n1 2 3 4 5 6 (define (fib x) (if (\u0026lt; x 3) 1 (+ (fib (- x 1)) (fib (- x 2))) ) ) duplicate compute procedure fib(- x 2)\n","date":"2023-04-30T19:44:28+08:00","permalink":"https://resyon.netlify.app/p/sicp_lec_1b/","title":"SICP_Lec_1b"},{"content":"black_box abstraction intro to mit-scheme\nprimitive objects primitive elements 1 2 3 4 ; number 3 ; operator - combination of primitive elements 1 2 3 4 5 6 7 8 9 ; combination of operands and operator- (+ 3 17.4 5) ; a more complex combination (+ 3 (* 5 6) 8 2) ; define a value (define A (* 5 5)) ; def A=5*5 (* A A); 5*5*5*5 (define B (+ A ( * 5 A))) (+ A (/ B 5)) ; 65 primitive procedures Attention define without \u0026lsquo;()\u0026rsquo; output a value otherwide a proceduce\n1 2 3 4 5 6 7 8 9 10 11 ; define a procedure (define (square x)(* x x)) (square 10) ; 100 ; the same as below ; key word `lambda` define a procedure, which is sy (define square ((lambda (x) (* x x)))) (define (mean-square x y) (+ (square x) (square y)) ) branch statement 1 2 3 4 5 6 7 8 9 10 11 12 13 ;conditional statement (define (abs x) (cond ((\u0026lt; x 0) (- x)) ((= x 0) 0) ((\u0026gt; x 0) x) ) ) ; if-else (define (abs x) (if (\u0026lt; x 0) (- x) x) ) example 1 2 3 4 5 6 7 8 9 10 11 12 ; a method to compute sqrt of x (define (average x y) ( / (+ x y) 2)) (define (good_enough? x) (\u0026lt; (abs (- (square guess) x) 0.01))) (define (improve guess x) (average guess (/ x guess))) (define (try guess x) (if (good-enough? guess x) guess (try (improve guess x)) ) ) a more compact method to implement it\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 (define (sqrt x) (define (good_enough? guess x) (define (abs x) (if (\u0026lt; x 0) (- x) x) ) (\u0026lt; (abs (- (square guess) x) ) 0.01) ) (define (improve guess) (define (average m n) (/ (+ m n) 2)) (average guess (/ x guess)) ) (define ((try guess) (if (good_enough? guess x) guess (try (improve guess)) )) ) (try 1) ) ","date":"2023-04-30T10:01:41+08:00","permalink":"https://resyon.netlify.app/p/sicp_lec_1a/","title":"SICP_Lec_1a"},{"content":"阶段性总结 overview 消失了一段时间，这一阶段要忙的事情，终于接近尘埃落定，写下这篇这些文字，也算是对过去的自己的一个交代。\n基本是流水帐的形式，记录了这段时间的时期\n1 //TODO:后面再更吧 ","date":"2023-04-30T09:03:27+08:00","permalink":"https://resyon.netlify.app/p/come_back/","title":"Come_back"},{"content":"ACM 模式输入输出 近期参加了几场笔试，对 ACM 模式的算法输入输出倍感恶心， 总结一下\nAPI fmt.Scanf: 和 C 一样 fmt.Scan: 同上 fmt.Scanln: 和名字不一样，他遇到空格会停下 strings.Fields(string) -\u0026gt; []string: 将字符串按空格分开 bufio.Reader.ReadBytes(byte) -\u0026gt; ([]byte, error): 读取目标字符前的所有字符 输入 输入样例 2 对坐标，n 行整型\n1 2 3 4 8 9 7 3 0 32 4 3 5 43 4 2 4 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 var x int var y int var m int var n int var vs [][]int // 1. c-like fmt.Scanf(\u0026#34;%d %d\u0026#34;, \u0026amp;x, \u0026amp;y) // // 2. fmt.Scan(\u0026amp;m, \u0026amp;n) // 3. read line reader := bufio.NewReader(io.Stdin) for { line, err := reader.ReadBytes(\u0026#39;\\n\u0026#39;) // now line is \u0026#34;0 32 4 3 5\u0026#34; var tmp []int for _, v := range strings.Fields(string(line)) { // split line by space vv, _ := strconv.Atoi(v) tmp = append(tmp, vv) } vs = append(vs, tmp) if err == io.EOF { break } } ","date":"2022-03-20T17:19:42+08:00","permalink":"https://resyon.netlify.app/p/acm-%E6%A8%A1%E5%BC%8F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","title":"ACM 模式输入输出"},{"content":"Redis 总结 Redis 对象系统 便于实现内存回收。为 C 这种没有 GC 的语言实现了基于 ***** 引用计数 ** 的垃圾回收 对象共享。多个相同的键可以共享同一块内存空间，节约资源 Redis 只对包含整数的字符串进行共享，主要原因在于共享其余更复杂的对象，在缓存的对象池中验证的成本过高，节省的少量空间不抵 CPU 消耗，实际仍是时间和空间的权衡\nRedis 持久化 Redis 状态 指 Redis 中非空的数据库 及 其中的键值对\n持久化是指 保存和恢复 Redis 状态 主要有 AOF, RDB 两种\n载入 没有专门的命令用于载入 AOF RDB 文件，Redis 会在启动时自动载入，并且 优先 载入 AOF 文件（AOF 的更新相对频繁些，丢失的键值对相对较少）\nRedis 分布式锁 定义 分布式锁是控制分布式系统或不同系统之间共同访问共享资源的一种锁实现.\n特征 互斥 超时释放. 便面死锁 可重入. 一个线程在持有锁的情况可以对其再次加锁, 防止锁在线程执行完临界区操作之前释放 高性能, 高可用, 低开销 单机分布式锁 1.0 SETNX 使用\n1 2 3 4 SETNX ${key} ${value} EXPIRE ${key} ${time_in_second} do sth DEL ${key} 原理: SETNX: key 不存在则设置, 否则不做任何动作\n优点: 简单 缺点: SETNX, EXPIRE 两条指令实现超时删除, 不为原子操作, 若在两条指令间发生意外, 将死锁\nv2.0 扩展 SET 使用:\n1 2 3 SET ${key} ${value} NX EX ${expire_time_in_second} do sth DEL ${key} 原理: 同 SETNX, 但设置值和设置超时两个动作为原子操作\n问题:\n提前释放: A 执行过程中, 超时, 键被删除, B 成功获得锁 误删: 上一过程中的 A 执行完成后, 仍然删除键, 导致 B 获得的锁被误删 v2.1 删除安全的 SET 解决:\n避免在耗时过长的操作中使用分布式锁; 使用 Redisson 续命 将值设置为随机数, 释放锁时检查 使用:\n1 2 3 SET ${key} ${random_value} NX EX ${expire_time_in_second} do sth check_key_valid \u0026amp;\u0026amp; DEL ${key} 问题: check_key_valid \u0026amp;\u0026amp; DEL ${key} 不为原子操作\nv2.2 删除安全的 SET 使用 LUA 脚本, 使其原子执行得到保证, (EVAL)\n1 2 3 4 5 if redis.call(\u0026#34;get\u0026#34;, KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;del\u0026#34;, KEYS[1]) else return 0 end v3.0 带 Redisson 的分布式锁 目的: 解决锁被提前释放的问题\n原理: 利用锁的可重入特性, 让获得锁的线程开启一个定时器的守护进程, 每 expireTime/3 执行一次, 检查该线程的锁是否存在, 存在则重新设置为 expireTime 续命, 防止锁由于过期提前释放\n多机分布式锁 Redlock ref 《Redis 设计与实现》 浅析 Redis 分布式锁解决方案 ","date":"2022-03-06T15:45:12+08:00","permalink":"https://resyon.netlify.app/p/redis-%E5%85%AB%E8%82%A1/","title":"Redis 八股"},{"content":"Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!\nFor more information about this theme, check the documentation: https://docs.stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2022-03-06T00:00:00Z","image":"https://resyon.netlify.app/p/hello-world/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://resyon.netlify.app/p/hello-world/","title":"Hello World"},{"content":"计网 TCP 说一下 TCP TCP 是位于运输层的协议，为应用层提供 面向连接的，可靠的 字节流 服务\n面向连接：一定是「一对一」才能连接，不能像 UDP 协议 可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；\n可靠的：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；\n字节流：消息是「没有边界」的，所以无论我们消息有多大都可以进行传输。并且消息是「有序的」，当「前一个」消息没有收到的时候，即使它先收到了后面的字节已经收到，那么也不能扔给应用层去处理，同时对「重复」的报文会自动丢弃。\nTCP 连接 1 2 3 4 5 Connections: The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection. 简单来说就是，用于保证 可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Socket、序列号和窗口大小称为连接。\n（源地址，源端口，目的地址，目的端口）4 元组可以唯一确定 1 个连接\nTCP 与 UDP 的区别 连接 TCP 是面向连接的传输层协议，传输数据前先要建立连接。\nUDP 是不需要连接，即刻传输数据。\n服务对象 TCP 是一对一的两点服务，即一条连接只有两个端点。\nUDP 支持一对一、一对多、多对多的交互通信\n可靠性 TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。\nUDP 是尽最大努力交付，不保证可靠交付数据。\n拥塞控制、流量控制 TCP 有拥塞控制和流量控制机制，保证数据传输的安全性。\nUDP 则没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率。\n首部开销 TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。\nUDP 首部只有 8 个字节，并且是固定不变的，开销较小。\n分段 TCP 对应用层传来的数据包进行分段，UDP 则不做处理\n为什么 IP 有分片，TCP 还要进行分段 为了保证 传输效能，也方便重传\n为了达到最佳的传输效能 TCP 协议在建立连接的时候通常要协商双方的 MSS 值，使 MSS + IP首部 \u0026lt;= MTU，确保单个 TCP 报文段无需再经过 IP 层进一步分片。这样，如果一个 TCP 分片丢失，进行重发时也是以 MSS 为单位，而不用重传所有的分片，大大增加了重传的效率\nTCP 如何保证 可靠 传输 确认应答，自适应的超时及重传策略确保不丢包 首部校验和确保不接收差错报文 序列号使得 TCP 能够通过重排序确保报文段不失序，不冗余 流量控制确保缓冲区不溢出 TCP 3 次握手 过程 原图 url\n客户端将 SYN 置为 1 ，随机产生一个 seq=i，并将数据包发送给服务器，客户端进入 SYN_SENT 状态，等待服务器确认。 服务器收到数据包后，由 SYN 为 1 知道客户端请求建立连接，将 SYN 和 ACK 置为1，ack=i+1，随机产生 seq=j，并将数据包发送给客户端以确认连接请求。服务器进入 SYN_RCVD 状态。 客户端收到确认后，检查 ack 是否为 i+1，ACK 是否为 1，如果正确将 ACK=1，ack 置为 j+1，并将数据包发送给服务器，服务器检查 ack 是否为 j+1，ACK=1，如果正确则连接建立成功，双方进入 ESTABLISHED 状态，完成三次握手。 原因（为什么要 3 次握手） 为什么不是两次？ 首要原因是为了防止旧的重复连接初始化造成混乱。\n在双方两次握手即可建立连接的情况下，假设客户端发送 A 报文段请求建立连接，由于网络原因造成 A 暂时无法到达服务器，服务器接收不到请求报文段就不会返回确认报文段。\n客户端在长时间得不到应答的情况下重新发送请求报文段 B，这次 B 顺利到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，客户端在收到 确认报文后也进入 ESTABLISHED 状态，双方建立连接并传输数据，之后正常断开连接。\n此时姗姗来迟的 A 报文段才到达服务器，服务器随即返回确认报文并进入 ESTABLISHED 状态，但是已经进入 CLOSED 状态的客户端无法再接受确认报文段，更无法进入 ESTABLISHED 状态，这将导致服务器长时间单方面等待，造成资源浪费。\n三次握手才能让双方均确认自己和对方的发送和接收能力都正常（有能力建立全双工连接）。2 次握手，如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。\n第一次握手：客户端只是发送处请求报文段，什么都无法确认，而服务器可以确认自己的接收能力和对方的发送能力正常；\n第二次握手：客户端可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；\n第三次握手：服务器可以确认自己发送能力和接收能力正常，对方发送能力和接收能力正常；\n可见三次握手才能让双方都确认自己和对方的发送和接收能力全部正常，这样就可以愉快地进行通信了。\n告知对方自己的初始序号值，并确认收到对方的初始序号值。（同步 seq）\nTCP 实现了可靠的数据传输，原因之一就是 TCP 报文段中维护了序号字段和确认序号字段，通过这两个字段双方都可以知道在自己发出的数据中，哪些是已经被对方确认接收的。这两个字段的值会在初始序号值得基础递增，如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。\n为什么不是 4 次 没有必要。因为三次握手已经可以确认双方的发送接收能力正常，双方都知道彼此已经准备好，而且也可以完成对双方初始序号值得确认，也就无需再第四次握手了。\n半连接队列(sync) 全连接队列(backlog) 积压值 (backlog) https://www.bilibili.com/video/BV1AK4y177WA\n作用 TCP 完成 3 次握手建立连接后，放入连接队列，这个队列的长度称为 backlog，取值范围 [0, 5]，通常为 5\n积压值说明的是 TCP 监听的端点已被 TCP 接受而等待应用层接受的最大连接数，对系统所允许的最大连接数或者并发服务器所能并发处理的客户数无影响\naccept queue满了之后的协议栈处理 1 cat /proc/sys/net/ipv4/tcp_abort_on_overflow 有效值:0或者1 0: 当 TCP 建立连接的 3 路握手完成后，将连接置入 ESTABLISHED 状态并交付给应用程序的 backlog 队列时，会检查 backlog 队列是否已满。若已满，通常行为是将连接还原至 SYN_ACK 状态，以造成 3 路握手最后的 ACK 包意外丢失假象――这样在客户端等待超时后可重发 AcK —―以再次尝试进入 ESTABLISHED 状态――作为一种修复/重试机制。\n1: 如果 tcp _abort_on_overflow 为 1，则在检查到 backlog 队列已满时，直接发 RST 包给客户端终止此连接\u0026ndash;此时客户端程序会收到 104 Connection reset by pee r错误\nSYN 攻击 原理 攻击者短时间内伪造不同 IP 的 SYN 报文，服务端回之 ACK + SYN 并进入 SYN_RCVD 状态，由于没有收到 ACK 的确认连接，长期停滞在 SYN_RCVD 状态，最终占满半连接队列，使得服务器不能为正常用户服务\n避免 通过修改内核参数，调整 队列大小 和 队列满时的行为 如何修改内核参数 ? 1 2 3 4 5 6 7 8 # 缓存网卡至内核数据包的队列大小 net.core.netdev_max_backlog # 半连接队列的大小，限制处于 `SYN_RCVD` 状态的连接数目 net.ipv4.tcp_max_syn_backlog # 对超出处理能力的 SYN 回复 RST net.ipv4.tcp_abort_on_overflow tcp_syncookies 原理\n半连接队列满后，不再插入后续的 SYN 包，而在回应的 SYN + ACK 包中夹带计算得到的 cookie，后续若收到 ACK 报文，则在检查合法性通过后将其直接加入 全连接队列\n打开方法\n1 net.ipv4.tcp_syncookies = 1 通过防火墙、路由器等过滤网关防护 TCP 四次挥手 过程 原图：小林coding\n客户端将 FIN 置为1，发送给服务器，用来关闭客户端到服务器的数据传送，客户端进入 FIN_WAIT_1 状态。 服务器收到 FIN 之后，回复 ACK，确认序号为收到序号+1，服务器进入 CLOSE_WAIT 状态，此时 TCP 连接处于半关闭状态，即客户端没有要发送的数据了，但是仍然可以接受服务器端的数据。 当服务器也没有要发送的数据时，向客户端发送一个 FIN，用来关闭服务器到客户端的数据传送，服务器进入 LAST_ACK 状态。 客户端收到 FIN 之后，进入 TIME_WAIT 状态，回复 ACK，确认序号为收到序号+1，服务器进入 CLOSED 状态，完成四次挥手 为什么 TIME_WAIT 要等 2MSL Linux 默认 MSL=30s MSL：报文最大生存时间\n确保 FIN 发起方的最后一个 ACK 被接收，否则接收方超时，重发 FIN 确保本次连接的报文段在网络中消失，以免干扰下一次连接. 2MSL 时间的 TIME_WAIT 状态能够确保网络上两个传输方向上尚未被接收到的、迟到的 TCP 报文段都已经消失（被中转路由丢弃）。 TCP 发送 RST 的情形 RST 表示复位，用来异常的关闭连接，在 TCP 的设计中它是不可或缺的。发送 RST 包关闭连接时，不必等缓冲区的包都发出去，直接就丢弃 缓存区的包发送 RST包。而接收端收到RST包后，也 不必 发送 ACK 包来确认。\n在一个已关闭的socket上收到数据 异常终止/异常关闭（如使用 SO_LINGER 选项，故意在关闭时发 RST 而非 FIN，以跳过 TIME_WAIT 拒绝连接，如限定本地 IP 地址的服务端接收到非本地的 SYN 时 一方已经关闭或异常终止而另一方仍未察觉的 TCP 连接，称为 半打开连接, 常见原因：主机异常；异常终止的一方重启后，若收到 TCP 报文，将回复 RST\n检测，处理 半打开连接 ：A关闭了连接，B却没有收到结束报文（如网络故障），此时B还维持着原来的连接。A重启之后收到了B发送的报文，则回应RST复位报文。 端口未打开：服务器程序端口未打开而客户端来连接。服务器程序 core dump 之后重启之前连续出现 RST 的情况。 端口不存在：若端口不存在，则直接返回 RST，同时 RST 报文接收通告窗口大小为0. 请求超时：建立连接过程中，一端认为接收超时，即使受到了想要的数据，也会发送 RST 拒绝进一步发送数据。 TCP 连接同时打开/关闭 同时打开 TCP 设计上会通过4次握手 成功 建立连接，但实现上不一定支持\n同时关闭 4次挥手关闭，最后都进入 TIME_WAIT\nTCP 各阶段状态可能原因及解决 TIMEWAIT 大量连接处于 TIME_WAIT 原因\nTIME_WAIT 状态说明是主动断开的连接，原因可能是应用所使用的反向代理服务器 (如 nginx) 未设置 connection: keep-alive\n危害\n内存占用 端口占用，一个 TCP 连接至少消耗 1 个本地端口，用尽则无法创建新连接 解决\n调整 net.ipv4.ip_local_port_range 增大可用的端口数量 复用处于 TIME_WAIT 的 socket 1 2 3 4 5 6 7 # turn on reuse net.ipv4.tcp_tw_reuse = 1 # make sure tcp timestamps on, default = 1 # 若客户端和服务端主机时间不同步时，客服端发送的消息会直接被拒绝 net.ipv4.tcp_timestamps = 1 重置 TIME_WAIT 连接 1 2 3 # 默认为 18000，超过该值后，系统会重置所有的 TIME_WAIT net.ipv4.tcp_max_tw_buckets = 18000 异常关闭连接，跳过 TIME_WAIT 1 2 3 4 5 6 struct linger so_linger; so_linger.l_onoff = 1; so_linger.l_linger = 0; // SO_LINGER 使得关闭时发送 RST，而非 FIN setsockopt(s, SOL_SOCKET, SO_LINGER, \u0026amp;so_linger,sizeof(so_linger)); CLOSE_WAIT 原因\n说明应用程序没有合适的关闭 socket，既可能是程序写的有问题没有关闭，或者因为 IO，锁陷入睡眠状态，也可能是 CPU 过载，得不到调度\n通常来说，一个 CLOSE_WAIT 会维持至少2个小时的时间（系统默认超时时间的是7200秒，也就是2小时）。如果服务端程序因某个原因导致系统造成一堆 CLOSE_WAIT 消耗资源，那么通常是等不到释放那一刻，系统就已崩溃。\n解决\n解决这个问题的方法还可以通过修改 TCP/IP 的参数来缩短这个时间，于是修改tcp_keepalive_*系列参数。 给每一个 socket 设置一个时间戳 last_update，每接收或者是发送成功数据，就用当前时间更新这个时间戳。定期检查所有的时间戳，如果时间戳与当前时间差值超过一定的阈值，就关闭这个 socket。\n其他 可以用 netstat -nat 命令查看tcp各个状态的数量，哪个端口被占用、套接字的状态、接收缓冲区和发送缓冲区中的数据个数、IP、还有程序名字。\nNOTE：\n（1）主动端出现大量的 FIN_WAIT_1 时需要注意网络是否畅通、出现大量的 FIN_WAIT_2 需要仔细检查程序为何迟迟收不到对端的 FIN（可能是主动方或者被动方的 bug ）、出现大量的 TIME_WAIT 需要注意系统的并发量/ socket 句柄资源/内存使用/端口号资源等。\n（2）被动端出现大量的 CLOSE_WAIT 需要仔细检查为何自己迟迟不愿调用 close 关闭连接（可能是bug，socket打开用完没有关闭）\nLISTENING：侦听来自远方的 TCP 端口的连接请求. 首先服务端需要打开一个 socket 进行监听，状态为 LISTEN。TCP 状态变化就是某个端口的状态变化，提供一个服务就打开一个端口。关闭不必要的端口是保证安全的一个非常重要的方面（ DDoS 攻击）。处于侦听 LISTENING 状态时，该端口是开放的，等待连接，但还没有被连接。\nSYN_SENT（客户端）：客户端通过应用程序 connect() 连接时，客户端发送一个SYN以请求建立一个连接，之后状态置为SYN_SENT 。正常情况下 SYN_SENT 状态非常短暂。\n如果发现有很多 SYN_SENT 出现，那一般有这么几种情况：\n一是你要访问的网站不存在或线路不好，\n二是用扫描软件扫描一个网段的机器，也会出现很多 SYN_SENT，\n三是可能中了病毒了，例如中了\u0026quot;冲击波\u0026quot;，病毒发作时会扫描其它机器（扫描过程发出了同步请求），这样会有很多 SYN_SENT出现。\n3，SYN_RECEIVED（服务端）：当服务器收到客户端发送的同步信号时，将标志位 ACK 和 SYN 置 1 发送给客户端，此时服务器端处 SYN_RCVD 状态，如果连接成功了就变为 ESTABLISHED，正常情况下 SYN_RCVD 状态非常短暂。\n如果发现有很多 SYN_RCVD 状态，那你的机器有可能被 SYN Flood 的 DoS (拒绝服务攻击)攻击了。这种情况下服务器端一般会重试（再次发送 SYN+ACK 给客户端）并等待一段时间后丢弃这个未完成的连接，这段时间的长度我们称为 SYN Timeout。\nESTABLISHED：代表一个打开的连接。 服务器出现很多 ESTABLISHED 状态：当客户端未主动 close 的时候就断开连接（没有正常进行四次挥手断开连接），若客户端断开的时候发送了 FIN 包，则服务端将会处于 CLOSE_WAIT 状态，若断开的时候未发送 FIN 包，则服务端处还是显示 ESTABLISHED 状态。当客户端重新连接服务器的时候，服务端肯定是 ESTABLISHED 状态，如果客户端重复上演这种情况，那么服务端将会出现大量的假的 ESTABLISHED 连接和 CLOSE_WAIT 连接。最终结果就是新的其他客户端无法连接上来，但是利用 netstat 还是能看到一条连接已经建立。\nFIN-WAIT-1：主动关闭(active close)端应用程序调用close()，于是其 TCP 发出 FIN 请求主动关闭连接，之后进入 FIN_WAIT_1 状态。等待远程 TCP 的连接中断请求，或先前的连接中断请求的确认。 如果服务器（作为主动关闭方？） 出现 shutdown 再重启，使用netstat -nat 查看，就会看到很多 FIN-WAIT-1 的状态。就是因为服务器当前有很多客户端连接，直接关闭服务器后，无法接收到客户端的 ACK。\nCLOSE-WAIT：被动关闭 (passive close) 端 TCP 接到 FIN 后，就发出 ACK 以回应 FIN 请求(它的接收也作为文件结束符传递给上层应用程序),并进入 CLOSE_WAIT。 大量 closewait 的原因：代码层面上未对连接进行关闭，比如关闭代码未写在 finally 块关闭，如果程序中发生异常就会跳过关闭代码；程序响应过慢，比如双方进行通讯，当客户端请求服务端迟迟得不到响应，就断开连接，重新发起请求，导致服务端一直忙于业务处理，没空去关闭连接。这种情况也会导致这个问题；\nFIN-WAIT-2：主动关闭端接到 ACK 后，就进入了FIN-WAIT-2。这就是著名的 半关闭状态 了，这是在关闭连接时，客户端和服务器两次握手之后的状态。在这个状态下，应用程序还有接受数据的能力，但是已经无法发送数据，但是也有一种可能是，客户端一直处于 FIN_WAIT_2 状态，而服务器则一直处于 CLOSE_WAIT 状态，而直到应用层来决定关闭这个状态。\nLAST-ACK：被动关闭端一段时间后，接收到文件结束符的应用程序将调用 close() 关闭连接。这导致它的 TCP 也发送一个 FIN, 等待对方的 ACK. 就进入了 LAST-ACK。\n使用并发压力测试的时候，突然断开压力测试客户端，服务器会看到很多 LAST-ACK。\n9，TIME-WAIT：在主动关闭端接收到 FIN 后，TCP 就发送 ACK包，并进入 TIME-WAIT 状态。等待足够的时间以确保远程TCP接收到连接中断请求的确认。\n这个状态是防止最后一次握手的数据报没有传送到对方那里而准备的（注意这不是四次握手，这是第四次握手的保险状态）。这个状态在很大程度上保证了双方都可以正常结束，但是，问题也来了。\n由于插口的 2MSL 状态（插口是 IP 和端口对的意思，socket），使得应用程序在 2MSL 时间内是无法再次使用同一个插口的，对于客户程序还好一些，但是对于服务程序，例如 httpd，它总是要使用同一个端口来进行服务，而在 2MSL 时间内，启动 httpd 就会出现错误（插口被使用）。为了避免这个错误，服务器给出了一个平静时间的概念，这是说在2MSL时间内，虽然可以重新启动服务器，但是这个服务器还是要平静的等待2MSL时间的过去才能进行下一次连接。\nCLOSED：没有任何连接状态\nCLOSING 状态：一般较少出现，这种是客户端和服务端同时发起了 FIN 主动关闭。如客户端发送 FIN 主动关闭，但是没有收到服务端发来的 ACK 确认，而是先收到了服务端发来的 FIN 关闭连接，所以必须是同时。\n在进入 CLOSING 状态后，只要收到了对方对自己发送的 FIN 的 ACK，收到 FIN 的 ACK 确认就进入 TIME_WAIT 状态，因此，如果 RTT(Round Trip Time TCP包的往返延时)处在一个可接受的范围内，发出的 FIN 会很快被 ACK 从而进入到 TIME_WAIT 状态，CLOSING 状态持续的时间就特别短，因此很难看到这种状态\nNagle 算法 该算法要求一个 TCP 连接上最多只能有一个未被确认分未完成的小分组，在该分组的确认之前不能发送其他的小分组\n作用 避免小分组 (tinygram) 在较慢的广域网上增加拥塞出现的可能，该算法的优越性在于自适应，通过确认的回复速率控制报文的传播速率\n弊端 即便关闭 Nagle 算法，ACK 也会延迟发送（累积确认），默认为 200ms 更大延迟发送的 TCP 报文进一步影响实时性\n滑动窗口 注意：窗口缩小时，右边沿并不（规定不能）向左移动\n拥塞窗口 为支持 慢启动 算法，发送方的 TCP 增加了另一个窗口，即 拥塞窗口\nTCP Tahoe TCP Reno 快速重传 算法最早出现的 4.3BSD Tahoe 版本，3 Dup ACK 后错误的使用慢启动；4.3BSD Reno 出现了 快速恢复\n快速恢复 ssthresh = cwnd / 2 cwnd = ssthresh + 3 * MSS\nTCP 坚持定时器 窗口为 0 时，发送方受到抑制，若此时接收方的通告窗口不为 0 的 ACK 恰好丢失，将发生死锁，发送方使用 坚持定时器 来周期性地向接收方查询窗口是否增大，这种查询窗口的报文称为 窗口探查\n保活机制 1 2 3 4 5 6 7 # 7200s 无活动，保活机制启动 net.ipv4.tcp_keepalive_time=7200 # 每次检测间隔 75s net.ipv4.tcp_keepalive_intvl=75 # 9次无响应则视为死亡 net.ipv4.tcp_keepalive_probes=9 HTTP 范围请求 ref\nHTTP 范围请求，需要 HTTP/1.1 及之上支持，如果双端某一段低于此版本，则认为不支持。 通过响应头中的 Accept-Ranges（只有可选参数 bytes）来确定是否支持范围请求。 通过在请求头中添加 Range 这个请求头，来指定请求的内容实体的字节范围。 在响应头中，状态码为 206 Partial Content; 416 Range Not Satisfiable, 通过 Content-Range 来标识当前返回的内容实体范围，并使用 Content-Length 来标识当前返回的内容实体范围长度。 在请求过程中，可以通过 If-Range 来区分资源文件是否变动，它的值来自 ETag 或者 Last-Modifled。如果资源文件有改动，会重新走下载流程。 cookie, session 的区别 cookie 实际上是一小段的文本信息。浏览器发送请求到服务器，如果服务器需要记录该用户的状态（比如：用户访问网页的次数，登录状态等），就使用 response 向客户端浏览器颁发一个 cookie。客户端浏览器会把 cookie 保存起来。当浏览器再次请求该网站时，浏览器就会把请求地址和 cookie 一同给服务器。服务器检查该 cookie，从而判断用户的状态。服务器还可以根据需要修改 cookie 的内容。\nsession 也是类似的记录用户状态的机制。不同的是\ncookie 保存在 客户端 浏览器中，而 session 保存在 服务器 上。 session 比 cookie 安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗。 cookie 能保存的 数据量 比 session 小，且 只能保存字符串； session 实现 ref\nsession 是保存在服务端的会话信息，使用 SessionID 标识\ncookie 可用，直接使用会话 cookie 暂存 SessionID cookie 不可用，使用 url 重写将 SessionID 告知服务端 ref 《 TCP/IP 详解（卷一）》 https://mp.weixin.qq.com/s/tH8RFmjrveOmgLvk9hmrkw https://github.com/cosen1024/Java-Interview/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8A.md https://blog.csdn.net/ewq21qwe/article/details/106578463 https://segmentfault.com/a/1190000040786792?utm_source=sf-similar-article https://www.nowcoder.com/questionTerminal/5a2d287965824d3ca93921bf89f8654c https://blog.csdn.net/hongweigg/article/details/38115675 ","date":"2022-02-20T13:01:00+08:00","permalink":"https://resyon.netlify.app/p/network-summary/","title":"Network Summary"},{"content":"操作系统 / Linux 绪论 什么是操作系统 操作系统是 管理计算机软硬件资源的计算机程序，同时也是计算机系统的内核与基石\n操作系统的基本功能 内存管理 内存分配，地址映射，内存保护与共享，虚拟内存等\n进程管理 进程控制，同步，通信；死锁处理，处理器掉调度\n设备管理 完成用户的 IO 请求，方便用户使用设备，提高设备利用率。主要包括缓冲管理，设备分配，设备处理，虚拟设备等\n文件管理 文件存储空间，目录的管理，文件读写管理和保护\n操作系统的特点 虚拟：一个物理实体映为多个逻辑对应物，分为空分复用（eg. 虚拟内存），时分复用（分时系统） 共享：资源可供内存中多个并发执行的进程共同使用 并发 异步：独立，不可预知的速度向前推进 中断 进程，线程，协程 进程 进程是资源分配的基本单位，用于管理资源（内存，文件，网络等资源）\n进程的特点 PCB 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作\n动态性（相对程序） 并发 独立 异步 特殊进程 守护进程：运行在后台的一种特殊进程，独立于控制终端并周期性地执行某些任务\n僵尸进程：子进程退出，而父进程未调用 wait/waitpid 获取子进程的状态信息，则该子进程的 进程描述符 等信息仍保存在系统中，称为僵尸进程\n孤儿进程：父进程退出，仍在运行的子进程称为孤儿进程，将由 init 进程收养\n线程 线程是独立调度的基本单位，一个进程可以有多个线程，共享进程资源\n超线程 超线程，也叫多线程，是指一种 处理器特性，一个 CPU可以保持两个线程状态，然后在纳秒级间隔内 切换。 实际上是并行。\n设备 I/O 设备 I/O 设备包括 设备控制器 和 设备本身 设备控制器 的作用是为操作系统提供简单的接口\n杂项 如何修改内核参数 ref\n/proc/sys 下的文件对应内核参数, ( / -\u0026gt; .)\n重启即恢复默认 1 2 3 4 5 6 7 # eg. modify net.ipv4.icmp_echo_igore_all = 1 echo 1 \u0026gt; /proc/sys/net/ipv4/icmp_echo_ignore_all # or sysctl -w net.ipv4.icmp_echo_ignore_all=1 持久化修改 1 2 3 4 5 6 7 # eg. on RHE7 # make sure a *.conf existed in /etc/sysctl.d/ # touch /etc/sysctl.d/icmp_ignore.conf echo \u0026#34;net.ipv4.icmp_echo_ignore_all = 1\u0026#34; \u0026gt; /etc/sysctl.d/icmp-ignore.conf ref https://blog.csdn.net/ewq21qwe/article/details/106578620?spm=1001.2014.3001.5501 https://www.rootusers.com/use-procsys-and-sysctl-to-modify-and-set-kernel-runtime-parameters https://github.com/KeKe-Li/data-structures-questions/blob/master/src/chapter06/golang.01.md ","date":"2022-02-20T12:58:28+08:00","permalink":"https://resyon.netlify.app/p/os-summary/","title":"OS Summary"},{"content":"博客迁移 之前一直使用 halo 管理博客，这个系统没什么毛病，就是 Java 写的，跑起来实在太占内存了，我的小服务器实在受不了，随便搞点别的，就得把他停下来。还有就是，小服务器不想要了，主要是续费有点贵，平时也用不着。\n现在迁移到了 github page，使用的引擎是 hugo，选了所谓的 Terminal 主题，极简极客风，我个人还是比较满意的，虽说自己肯定是算不上极客。\n感兴趣的朋友可以参考 Host on Github 这篇官方文章，将博客托管至 Github 上。\n","date":"2022-02-19T18:47:06+08:00","permalink":"https://resyon.netlify.app/p/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/","title":"博客迁移"},{"content":"Mysql 事务两阶段提交 overview 准确的说是使用innodb引擎的mysql事务的两阶段提交 redo-log是innodb引擎在存储引擎层面实现的\n例表\n1 2 3 4 create table t( id int primary key, c int ); 如下查询\n1 2 update `t` set c=c+1 where `id`=2; 有以下过程\n两阶段提交的必要性 主要是保证redo-log 和 bin-log的一致性。这种必要性体现在异常恢复上。 由常识我们知道 redo-log用于保证事务的原子性和持久性，记录的是物理日志，由存储引擎实现 bin-log用于归档， 记录的逻辑日志，由mysql server 层实现\n若不保证二者同步更新（不使用两阶段提交，即在二者之一完成之后立即提交事务），将出现以下两种情况\nredo-log -\u0026gt; commit -\u0026gt; bin-log 若在commit和bin-log间异常重启，系统能根据redo-log恢复事务，bin-log于是实际上少了一条记录，这就影响了后续对bin-log的使用，如构建从库，恢复到某一检查点\nbin-log -\u0026gt; commit -\u0026gt; redo-log 若在commit和redo-log间异常重启，系统无法恢复事务，而bin-log多了一条记录，而数据库里实际没有，以后用bin-log也会出现与原库不一样的问题\n总结 redo-log和bin-log都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。\nref 丁奇《MySQL实战45讲》\n","date":"2021-12-16T16:03:22+08:00","permalink":"https://resyon.netlify.app/p/mysql-%E4%BA%8B%E5%8A%A1%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/","title":"mysql 事务两阶段提交"},{"content":"web-security test 试题手写40 整个攻击流程（渗透过程） 渗透-信息的收集 PPT\n收集域名信息 whois 查询域名 注册与否，注册域名的详细信息（如域名所有人、域名注册商） tools: whois(kali), 爱站工具网(https://whois.aizhan.com)、站长之家(http://whois.chinaz.com)和VirusTotal(https://www.virustotal.com) 备案信息 tools: ICP备案查询网：http://www.beianbeian.com, 天眼查：http://www.tianyancha.com。 收集敏感信息 利用搜索引擎，轻松得到想要的信息，还可以用它来搜集数据库文件，SQL注入，配置信息、源代码泄露、未授权访问和rebots.txt等敏感信息 google 常用语法 通过Burp Suite的Repeater功能，（如运行的Server类型及版本，PHP的版本信息等） 收集子域名信息 因为子域名通常护甲较弱\n子域名检测工具 (eg. Layer子域名挖掘机、K8、wydomain、Sublist3r、dnsmaper、subDomainsBrute、Maltego CE)\n搜索引擎枚举 site: ${target_domain}\n第三方聚合应用枚举 很多第三方服务汇聚了大量DNS数据集，可通过它们检索某个给定域名的子域 名。只需在其搜索栏中输入域名，就可检索到相关的域名信息\n证书透明度公开日志枚举 最简单的方法就是使用搜索引擎搜索一些公开的CT日志\n收集常用端口信息 关注常见应用的默认端口和在端口上运行的服务，便于渗透 tools: Nmap，无状态端口扫描工具Masscan、ZMap和御剑高速TCP端口扫描工具\n指纹识别 指纹是指网站CMS指纹识别、计算机操作系统及Web容器的指纹识别 应用程序一般在html、js、css等文件中包含一些特征码(CMS指纹)，那么当碰到其他网站也存在此特征时，就可以快速识别出该CMS，所以叫作指纹识别。 CMS又称整站系统或文章系统, 常见的CMS有Dedecms（织梦）、Discuz、PHPWEB、PHPWind、PHPCMS、ECShop、Dvbbs、SiteWeaver、ASPCMS、帝国、Z-Blog、WordPress等。 tools: 御剑Web指纹识别、WhatWeb、WebRobo、椰树、轻量WEB指纹识别等\n寻找真实ip 无CDN: tools: www.ip138.com 有CDN: 我赌他不考 收集敏感目录 社会工程学 OWSP十大安全漏洞 OWASP组织：开放式Web应用程序安全项目（OWASP，Open Web Application Security Project）是一个组织，它提供有关计算机和互联网应用程序的公正.实际.有成本效益的信息。其目的是协助个人.企业和机构来发现和使用可信赖软件。 十个漏洞：\n注入 失效的身份认证和会话管理 跨站脚本 不安全的直接对象引用 安全配置错误 敏感信息泄露 功能级访问控制缺失 跨站请求伪造 使用含有已知漏洞的组件 未验证的重定向与 转发 web 及工作原理 web, php, mysql, etc 网安入门 ppt\nweb框架怎样的结构，哪三层，作用是什么 下面给的原答案好像有点问题 说的可能是 这个 web应用-\u0026gt;应用服务器-\u0026gt;数据库服务器\nweb应用：可以通过Web访问的应用程序, eg. WordPress 应用程序服务器（英语：application server）是一种软件框架，提供一个应用程序运行的环境。 用于为应用程序提供安全.数据.事务支持.负载平衡大型分布式系统管理等服务。eg. Apache, IIS 数据库服务器：是联系Web服务器与数据库管理系统（DBMS）的中间件是负责处理所有的应用程序服务器，包括在web服务器和后台的应用程序或数据库之间的事务处理和数据访问。eg\u0026hellip; 三个工具主要功能，简单操作要会 burpsuite ppt\nref\n用于测试网络应用程序安全性的图形化工具(java)\nHTTP Proxy — 拦截、查看、修改所有在客户端与服务端之间传输的数据。(他就是个拦截，指道的，发挥其他功能要靠下面的模块) Scanner — Web 应用程序安全扫描器，用于执行 Web 应用程序的自动漏洞扫描。 Intruder — 对 Web 应用程序执行自动攻击。提供可配置算法，可生成恶意 HTTP 请求。Intruder 工具可以测试和检测 SQL 注入、跨站脚本、参数篡改和易暴力攻击的漏洞。 Spider — 自动抓取 Web 应用程序的工具。可以与手工映射技术一起使用，加快映射应用程序内容和功能的过程。 Repeater — 用来手动测试应用程序的简单工具。用于修改对服务器的请求，重新发送并观察结果。它最大的用途就是能和其他 Burp Suite工具结合起来使用。可以将目标站点地图、 Burp Proxy/浏览记录、 Burp Intruder的攻击结果，发送到 Repeater上，并手动调整这个请求来对漏洞的探测或攻击进行微调。 Decoder — 将已编码的数据转换为其规范形式，或将原始数据转换为各种编码和散列形式的工具。能够利用启发式技术智能识别多种编码格式。 Comparer — 在任意两个数据项之间执行比较（一个可视化的“差异”）的工具。 Extender — 允许安全测试人员加载 Burp 扩展，使用安全测试人员自己的或第三方代码扩展 Burp 的功能 Sequencer — 分析数据项样本随机性的工具。可以用于测试应用程序的会话令牌或其他重要的数据项，如反 CSRF 令牌、密码重置令牌等。 nmap Nmap( Network Mapper,网络映射器), 网络探测和安全审核工具。用来快速扫描大型网络，包括主机探测与发现、开放的端口情况、操作系统与应用服务指纹识别、WAF识别及常见安全漏洞。它的图形化界面是Zenmap,分布式框架为Dmap。 特点：\n主机探测：探则网络上的主机，如列出响应TCP和CMP请求、ICMP请求、开放特别端口的主机 端口扫描：探测目标主机所开放的端口 版本检测：探测目标主机的网络服务，判断其服务名称及版本号 系统检测：探测目标主机的操作系统及网络设备的硬件特性 支持探测脚本的编写：使用Nmap的脚本引擎(NSE)和lua编程语言。 使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 扫主机 nmap 192.168.1.105 192.168.1.106 # 1个或多个 nmap 192.168.1.105-106 # 和上面一样 nmap 192.168.1.0/24 # 团灭整个网段 nmap --li /tmp/file --exclude 192.168.1.105 --excludefile /tmp/file1 # 扫`file`整个文件, 除了`192.168.1.105`和文件`file1`里头的 # 路由跟踪 nmap --traceroute 192.168.1.105 # 扫端口 nmap 192.168.0.100 –p 21,22,23,80 # 扫在线状况 nmap –sP 192.168.0.100/24 # 操作系统指纹识别 nmap –O 192.168.0.105 # 识别操作系统的版本 # 服务版本检测 nmap -sV 192.168.0.105 # 检测开放端口对应的服务版本信息 # 探测防火墙状态 nmap -sF -T4 192.168.0.105 # FIN扫描用于识别端口是否关闭，RST: 端口关闭，否则是open或 filtered状态. sqlmap ppt\n使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 扫单个url, url都加双引号就对了 sqlmap.py -u \u0026#34;http://192.168.1.104/sql1/Less-1/?id=1\u0026amp;uid=2\u0026#34; # 扫文件里的 sqlmap.py -r desktop/1.txt # show databases; sqlmap.py -u http://127.0.0.1/sql/Less-1/?id=1 --dbs # use security; show tables; sqlmap.py -u http://127.0.0.1/sql/Less-1?id=1 -D security --tables # desc security.users; sqlmap.py -u \u0026#34;http://127.0.0.1/sql/Less-1/?id=1\u0026#34; -D security -T users --columns # select * from security.users; sqlmap.py -u “http://127.0.0.1/sql/Less-1/?id=1” -D security -T users --dump # 获取数据库的所有用户 sqlmap.py -u \u0026#34;http://127.0.0.1/sql/Less-1/?id=1\u0026#34; -users # 获取当前网站数据库的名称 sqlmap.py -u “http://127.0.0.1/sql/Less-1/?id=1” --current-db # 获取当前网站数据库的用户名称 sqlmap.py -u “http://127.0.0.1/sql/Less-1/?id=1” --current-user 实操 SQL注入 ppt\nSQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。\nSQL注入漏洞的产生需要满足以下两个条件： 1、参数用户可控：前端传给后端的参数内容是用户可以控制的。 2、参数带入数据库查询：传入的参数拼接到SQL语句，且带入数据库查询\n考点 虚拟机下完成union boolean 报错注入 文件上传 ppt\n利用文件上传漏洞将可执行脚本程序上传到服务器中，获得网站的权限，或者进一步危害服务器\njs绕过 原因：这种情况只是对http head中的Content-Type字段进行限制 方案：此时只需要使用burpsuite啥的把Content-Type改了\n图马绕过 原因：服务端对文件进行了检测 方案：他没给，肯定不考\n考点 文件上传\u0026ndash;js检测绕过漏洞 文件后缀(改名) 文件类型绕过(burpsuite改Content-Type)\n暴力破解 ppt\nXSS 在Web的世界里有各种各样的语言，于是乎对于语句的解析大家各不相同，有一些语句在一种语言里是合法的，但是在另外一种语言里是非法的。这种二义性使得黑客可以用代码注入的方式进行攻击一将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动。只要破坏跨层协议的数据/指令的构造，我们就能攻击。 XSS的基本实现思路很简单：比如持久型XSS通过一些正常的站内交互途径，例如发布评论，提交含有Javascript的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本，从而被攻击。\n考点 XSS反射型/存储型 方法一:用\u0026lt;img\u0026gt;标签代替\u0026lt;script\u0026gt; \u0026lt;img src=1 onerror=alert('xss')\u0026gt; 方法二:双写绕过\u0026lt;s\u0026lt;script\u0026gt;cript\u0026gt;alert('xss')\u0026lt;/script\u0026gt; 方法三:大小写绕过 \u0026lt;ScRipt\u0026gt;alert('xss')\u0026lt;/ScRipt\u0026gt;\nDOM型 ?default=\u0026lt;script\u0026gt;alert(document.cookie)\u0026lt;/script\u0026gt;\n上面不行，试试下面的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 第一类：Javascript URL \u0026lt;a href=\u0026#34;javascript:alert(\u0026#39;test\u0026#39;)\u0026#34;\u0026gt;link\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;java\u0026amp;#115;cript:alert(\u0026#39;xss\u0026#39;)\u0026#34;\u0026gt;link\u0026lt;/a\u0026gt; \u0026lt;iframe src=javascript:alert(\u0026#39;xss\u0026#39;)\u0026gt; 第二类：Inline style \u0026lt;div style=\u0026#34;color: expression(alert(\u0026#39;XSS\u0026#39;))\u0026#34;\u0026gt; \u0026lt;div style=color:expression\\(alert(1))\u0026gt;\u0026lt;/div\u0026gt; 第三类：JavaScript 事件 \u0026lt;img src=1 onclick=alert(\u0026#39;xss\u0026#39;)\u0026gt; \u0026lt;img src=1 onerror=alert(\u0026#39;xss\u0026#39;)\u0026gt; \u0026lt;body onload=alert(\u0026#39;xss\u0026#39;)\u0026gt; 第四类：Script标签 \u0026lt;script\u0026gt;alert(\u0026#39;xss\u0026#39;)\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;alert(document.cookie)\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;window.location=\u0026#39;http://www.163.com\u0026#39;\u0026lt;/script\u0026gt; \u0026lt;scr\u0026lt;script\u0026gt;ipt\u0026gt;alert(\u0026#39;XSS\u0026#39;)\u0026lt;/scr\u0026lt;script\u0026gt;ipt\u0026gt; \u0026lt;SCRIPT\u0026gt;alert(\u0026#39;xss\u0026#39;)\u0026lt;/SCRIPT\u0026gt; 第五类：CSS import \u0026lt;style\u0026gt;@import url(\u0026#34;http://attacker.org/malicious.css\u0026#34;);\u0026lt;/style\u0026gt; \u0026lt;style\u0026gt;@imp\\ort url(\u0026#34;http://attacker.org/malicious.css\u0026#34;);\u0026lt;/style\u0026gt; \u0026lt;STYLE\u0026gt;@im\\port\u0026#39;\\ja\\vasc\\ript:alert(\u0026#34;XSS\u0026#34;)\u0026#39;;\u0026lt;/STYLE\u0026gt; \u0026lt;STYLE\u0026gt;@import\u0026#39;http://jb51.net/xss.css\u0026#39;;\u0026lt;/STYLE\u0026gt; CSRF 原理 CSRF( Cross- site request forgery,跨站请求伪造)也被称为 One ClickAttackt或者 Session Riding,通常缩写为CSRF或者XSRF,是一种对网站的恶意利用。尽管听起来像跨站脚本(XSS),但它与XSs非常不同，XSS利用站点内的信任用户而CSRF通过你装成受信任用户请求受信任的网站。与XSS攻击相比CSRF攻击往往不大流行（因此对其进行防范的资源也相当稀少）也难以防范，所以被认为比XSS更具危险性。\n攻击者利用目标用户的身份，以目标用户的名义执行某些非法操作。CSRF能够做的事情包括：以目标用户的名义发送邮件、发消息，盗取目标用户的账号，甚至购买商品、虚拟货币转账，这会泄露个人隐私并威胁到了目标用户的财产安全。\n考点 虚拟机下CSRF攻击\n简单的话 构建响应的url， http://127.0.0.1/dvwa/vulnerabilities/csrf/?password_new=45\u0026amp;password_conf=45\u0026amp;Change=Change# 在本浏览器新建页面后进去构建好的url，页面显示密码修改成功。\n中等的话 杂项 哥斯拉木马的使用，远程控制，远程控制机上上传文件生成一个用户\nPhp代码理解，分析漏洞\n网络安全形式 （通过什么方法防范什么问题达到什么效果）通过采取必要措施，防范对网络的攻击、入侵、干扰、破坏和非法使用以及意外事故，使网络处于可靠运行的状态，以及保障网络的存储，传输，处理信息的完整性，保密性，可用性的能力。 网络安全：网络运行（服务器崩溃）+网络信息安全 网络安全渗透 攻击 网页篡改 远程攻击 渗透过程（流程图会画） 踩点 提权 检索方式:site inurl 网络安全 渗透工程师 职业 开发 大数据 SQL注入 Union boolean 报错信息 Union 函数 -版本号（目的：漏洞 利用） Boolean \u0026ndash;(yes/no) 枚举 报错信息 登录 查询 SQL语句 标准 常规 异类 库、表、字段\u0026mdash;\u0026gt; 管理 系统表 \u0026ndash;\u0026gt; 加密存储 工具 bs\nsqlmap nmap bs\u0026mdash;proxy代理（浏览器） 发出请求 响应response 扫描scanner\n拦截 篡改 钓鱼 代理 暴力破解（密码字典 原理 工具） html静态 交互 部署 php使用\u0026mdash;数据库增删改查IDUS 服务(sqldemo） index.php xss js php 交互 对话框 反射型 存储型 脚本 执行 dom型 文件上传 哥斯拉\u0026mdash;做木马 php 绕过 Js 文件类型 绕过 文件后缀 绕过 远程控制 IP端口 URL \u0026mdash;\u0026gt;网络 靶机 物理机 （必考） test.sql上传数据库 导入数据 CSRF KALI msf ms ","date":"2021-12-11T19:34:37+08:00","permalink":"https://resyon.netlify.app/p/%E7%BD%91%E5%AE%89%E9%80%89%E4%BF%AE%E8%AF%BE%E7%9A%84%E6%9C%9F%E6%9C%AB%E8%80%83%E5%89%8D%E6%80%A5%E6%95%91/","title":"网安选修课的期末考前急救"},{"content":"Awesome way to make use of nil channel common Send and receive operations on a nil channel block forver. It\u0026rsquo;s a well documented behavior\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package main import ( \u0026#34;fmt\u0026#34; ) func main() { var ch chan int go func() { fmt.Println(\u0026#34;ready to read from ch\u0026#34;) fmt.Printf(\u0026#34;get val: %v\\n\u0026#34;, \u0026lt;-ch) }() fmt.Println(\u0026#34;ready to write val to ch\u0026#34;) ch \u0026lt;- 17 } got output awesome usage This behavior can be used as a way to dynamically enable and disable case blocks in a select statement.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package main import( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { inch := make(chan int) outch := make(chan int) go func() { // (0) `in != nil` var in \u0026lt;- chan int = inch var out chan \u0026lt;- int var val int for { // enable and disable `out`, `in` select { // (1)(3) out == nil =\u0026gt; { blocking } // (2)(4) out != nil =\u0026gt; { out \u0026lt;- val; in != nil } case out \u0026lt;- val: out = nil in = inch // (1)(3) in != nil =\u0026gt; { out != nil; val \u0026lt;- in; in == nil } // (2)(4) in == nil =\u0026gt; { blocking } case val = \u0026lt;- in: out = outch in = nil } } }() go func() { // (1) blocking // (2) result: 1 // (3) blocking // (4) result: 2 for r := range outch { fmt.Println(\u0026#34;result:\u0026#34;,r) } }() time.Sleep(0) inch \u0026lt;- 1 inch \u0026lt;- 2 time.Sleep(3 * time.Second) } ref http://devs.cloudimmunity.com/gotchas-and-common-mistakes-in-go-golang/index.html\n","date":"2021-12-08T20:45:20+08:00","permalink":"https://resyon.netlify.app/p/awesome-way-to-make-use-of-nil-channel/","title":"awesome way to make use of nil channel"},{"content":"How does go calculate a hash value for keys in a map? ref\noriginal The language spec doesn\u0026rsquo;t say, which means that it\u0026rsquo;s free to change at any time, or differ between implementations.\nThe hash algorithm varies somewhat between types and platforms. As of now: On x86 (32 or 64 bit) if the CPU supports AES instructions, the runtime uses aeshash, a hash built on AES primitives, otherwise it uses a function \u0026ldquo;inspired by\u0026rdquo; xxHash and cityhash, but different from either. There are different variants for 32-bit and 64-bit systems. Most types use a simple hash of their memory contents, but floating-point types have code to ensure that 0 and -0 hash equally (since they compare equally) and NaNs hash randomly (since two NaNs are never equal). Since complex types are built from floats, their hashes are composed from the hashes of their two floating-point parts. And an interface\u0026rsquo;s hash is the hash of the value stored in the interface, and not the interface header itself.\nAll of this stuff is in private functions, so no, you can\u0026rsquo;t access Go\u0026rsquo;s internal hash for a value in your own code.\nif two things compare equal with == they must have equal hashes (or maps wouldn\u0026rsquo;t work\u0026hellip; this is also the reasoning behind all of the special cases I outlined above). That means that strings hash their bodies, not their headers. And structs compose the hashes of all of their fields. I can\u0026rsquo;t find the code actually implementing that, but the tests and the comparison rules make it clear.\nsummary 平台/体系结构相关, func hash绑定至_type.alg中, x86下且支持AES指令使用基于AES原语的aeshash, 否则\u0026hellip; float的计算方式比较特殊, 由于IEEE-754. interface的哈希根据存储其中的hash value计算出, 而非头部 string, struct 的哈希值由构成他们的域/字符计算得出, 而非头部 golang定义的hash均为私有, 但可以通过==推断二者的hash value是否相等, 但注意 slice, map, func, 带有前面3者的array \u0026amp;\u0026amp; struct不可比较 ","date":"2021-10-10T15:27:19+08:00","permalink":"https://resyon.netlify.app/p/how-does-go-calculate-a-hash-value-for-keys-in-a-map/","title":"How does go calculate a hash value for keys in a map?"},{"content":"golang nil interface ref\npreparation: structure of interface entry common interface 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 type iface struct { tab *itab data unsafe.Pointer } type itab struct { inter *interfacetype _type *_type link *itab hash uint32 // copy of _type.hash. Used for type switches. bad bool // type does not implement interface inhash bool // has this itab been added to hash? unused [2]byte fun [1]uintptr // variable sized } type interfacetype struct { typ _type pkgpath name mhdr []imethod } interface{} 1 2 3 4 type eface struct { _type *_type data unsafe.Pointer } nil interface nil := type == nil \u0026amp;\u0026amp; data == nil struct nil := data == nil\ncommon interface 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 type Coder interface { code() } type Gopher struct { } func (g Gopher) code() { } func main() { var c Coder fmt.Println(c == nil) // true fmt.Printf(\u0026#34;c: %T, %v\\n\u0026#34;, c, c) // c: \u0026lt;nil\u0026gt;, \u0026lt;nil\u0026gt; var g *Gopher fmt.Println(g == nil)\t// true // declare an interface `g`, type of `g` is still `nil` fmt.Printf(\u0026#34;g: %T, %v\\n\u0026#34;, g, g) // g: *main.Gopher, \u0026lt;nil\u0026gt; // assign interface `c` struct type `g` c = g fmt.Println(c == nil)\t// false fmt.Printf(\u0026#34;c: %T, %v\\n\u0026#34;, c, c) // c: *main.Gopher, \u0026lt;nil\u0026gt; } output\n1 2 3 4 5 6 true c: \u0026lt;nil\u0026gt;, \u0026lt;nil\u0026gt; true g: *main.Gopher, \u0026lt;nil\u0026gt; false c: *main.Gopher, \u0026lt;nil\u0026gt; interface{} 1 2 3 4 5 6 7 8 func main() { var i interface{} fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, i, i) // \u0026lt;nil\u0026gt;, \u0026lt;nil\u0026gt; i = 8 fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, i, i) // int, 8 v, _ := i.(int) fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, v, v) // int, 8 } output\n1 2 3 \u0026lt;nil\u0026gt;, \u0026lt;nil\u0026gt; int, 8 int, 8 ","date":"2021-10-09T17:47:39+08:00","permalink":"https://resyon.netlify.app/p/golang-nil-interface/","title":"golang nil interface"},{"content":" 完成6.s081 lab1 后对pipeline, file descriptor 有了一定了解，做个笔记\npipeline (pipe) A pipe is a small kernel buffer exposed to processes as a pair of file descriptors, one for reading and one for writing. Writing data to one end of the pipe makes that data available for reading from the other end of the pipe. Pipes provide a way for processes to communicate.\n使用: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int pd[2]; // make pipeline, return pd[0] for read, pd[1] for write if(pipe(pd) \u0026lt; 0){ // handle fail fprintf(stderr, \u0026#34;fail to make pipeline\\n\u0026#34;); exit(1); } int pid = fork(); if(pid \u0026lt; 0){ // handle fail }else if(pid == 0){ // child char cnt = \u0026#34;this is test content from child process\u0026#34;; write(pd[1], cnt, strlen(cnt)); exit(0); }else{ // parent char buf[128]; // assume that size of content to read would not exceed buf read(pd[0], buf, sizeof(buf)); printf(\u0026#34;get buf from child, buf=\u0026lt;%s\u0026gt;\\n\u0026#34;, buf); } file descriptor (fd) fd是对广义上的UNIX file进行引用的一层抽象，这层抽象使得在操作regular file, device, pipeline 等文件时，表面上一致，操作起来简单，(都可使用read(int fd,..); write(int fd,...)等透过fd的API), 但实现上，不同类型的文件大不相同.\n几个重要的fd特性 总是自动打开3个fd, 0=stdin , 1=stdout, 2=stderr 总是选取最小的fd 1 2 3 close(1); int fd = open(\u0026#34;/tmp/test.c\u0026#34;, O_RDONLY); fprintf(stderr, \u0026#34;fd=%d\\n\u0026#34;, fd); // fd=1 file descriptor table由进程维护，即进程间fd互不影响 以下代码来自lab 1实验primes, 实现了下图所示的埃氏筛法 为摆脱xv6对fd数目的限制，每个子进程都对管道传入的fd进行了多次重定向, 但在子进程改变fd并不影响父进程，程序能正常执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // redirect pd[k] to k, both pd[k] and k are fd static void redirect(int k, int pd[]){ close(k); dup(pd[k]); close(pd[0]); close(pd[1]); } static void loop(){ int p, v, pid; int pd[2]; if(read(0, \u0026amp;p, sizeof(int))){ printf(\u0026#34;prime %d\\n\u0026#34;, p); pipe(pd); pid = fork(); if(pid \u0026lt; 0){ fprintf(stderr, \u0026#34;fail to fork, current pid=%d\\n\u0026#34;, getpid()); return; }else if(pid \u0026gt; 0){ redirect(0, pd); loop(); }else{ redirect(1, pd); while(read(0, \u0026amp;v, sizeof(int))){ if(v % p != 0){ write(1, \u0026amp;v, sizeof(int)); } } } } } int main(){ int p[2]; pipe(p); if(fork()\u0026gt;0){ redirect(0, p); loop(); }else{ redirect(1, p); for(int i=2; i\u0026lt;35;++i){ write(1, \u0026amp;i, sizeof(int)); } } exit(0); } 经由fork和dup得到，的对同一文件的fd, 它们共享偏移 fork\n1 2 3 4 5 6 7 8 9 10 11 if(fork() == 0){ fprintf(stdout, \u0026#34;hello \u0026#34;); exit(0); }else{ wait((int*)0); // wait child exit fprintf(stdout, \u0026#34;world\\n\u0026#34;); exit(0); } // always get // \u0026#34;hello world\\n\u0026#34; ","date":"2021-09-11T10:49:41+08:00","permalink":"https://resyon.netlify.app/p/unix-pipeline-file-descriptor/","title":"UNIX pipeline \u0026 file descriptor"},{"content":"新建用户，添加至sudo的若干步骤\n1 usermod -aG root username 这时候，我在debian上依旧不行 (这是因为/etc/sudoer的配置中，并没有指定root用户组中的成员都可以使用sudo)\n1 adduser useradd root 还是没用，选择直接编辑/etc/sudoer, 注意到这个文件的权限 通常使用sudoedit进行编辑， 这个时候如果出现语法错误，会非常蛋疼，查了资料后发现， visudo是个更好的选择，visudo不会在/etc/sudoer语法错误时拒绝编辑该文件，还会在保存后语法错误时提示重新编辑 ","date":"2021-08-14T14:26:34+08:00","permalink":"https://resyon.netlify.app/p/editor-for-/etc/sudoer/","title":"Editor for /etc/sudoer"},{"content":"binary-search 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;vector\u0026gt; using namespace std; int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int i = 0, j = nums.size()-1; //这里的类型别用auto, 否则后续 //mid - 1 可能溢出 int mid; while (i \u0026lt;= j) { mid = (i + j ) / 2; if (nums[mid] == target) { return mid; }else if (nums[mid] \u0026gt; target)\tj = mid-1; //注意此处 -1 else i = mid+1; //以及此处 + 1 //否则容易陷入死循环 } return -1; } ","date":"2021-05-21T07:56:13+08:00","permalink":"https://resyon.netlify.app/p/%E6%95%B0%E7%BB%84/","title":"数组"},{"content":"切片声明 此前特别喜欢用字面量声明一个切片, 即， slice := []int{} , 读了uber go 风格指南后发现，这样其实不大好\n此前总是那样做是担心声明的方式var slice []int，slice未初始化，\n然而， 切片的默认值实际是有效的\n切片默认值(nil)使用 ","date":"2021-05-09T21:54:38+08:00","permalink":"https://resyon.netlify.app/p/golang%E5%88%87%E7%89%87%E4%BD%BF%E7%94%A8%E9%A3%8E%E6%A0%BC/","title":"Golang切片使用风格"},{"content":"About Me 关于我，普通的19级在校学生，惯用Golang/Java/C， 不大喜欢Python， 会整点web的后端开发，对中间件有些兴趣。业余看些动漫，人生没啥追求，唯一的愿望是快乐。\nAbout Resyon\u0026rsquo;s World 关于本站，不会有多少访问量的个人博客，主要用于记录一些个人学习中的笔记.\n","date":"2021-05-08T13:45:42+08:00","permalink":"https://resyon.netlify.app/p/about-resyon/","title":"About Resyon"},{"content":"复活 原本不打算再写博客，一个是懒，另一个是确实也没啥好写的。 偶然的机会又得用上服务器，单挂个小程序的后端，看着资源利用率，觉得难受，于是这个博客又复活了,还换了个域名。 其实说起博客，更像是自娱自乐的地方，正如站名Resyon's World，到也无所谓了。\nNext? 最近有点忙，一个小程序大赛，一个互联网+，但忙里偷闲也能干点自己觉得有意思的 对桌面环境之类的一直有点兴趣，最近研究一下\nX11 X-org Do-Chat/Wine ","date":"2021-05-06T21:24:40+08:00","permalink":"https://resyon.netlify.app/p/see-you-again/","title":"See You Again"}]